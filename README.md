# Серверная часть: хранение пользователей и очков

В проекте реализовано разделение на два сервера:

- **React-приложение** (порт 3000) — отвечает за игровой интерфейс, регистрацию, вход, отображение статистики и игровой процесс.
- **API сервер (user-api.js)** (порт 3001) — отвечает за хранение и обновление профилей пользователей и их очков в файле `src/users.json`.

### Как это работает

1. **Регистрация пользователя**
	- При регистрации новый пользователь сразу записывается в файл `src/users.json` через API, даже если не сыграл ни одной игры.
	- Имя пользователя появляется в статистике сразу после регистрации.

2. **Вход пользователя**
	- При входе данные пользователя подтягиваются из файла `src/users.json` через API.

3. **Сохранение очков**
	- Очки пользователя сохраняются в файл только если раунд был доигран до конца (при завершении раунда).
	- Если пользователь не доиграл раунд до конца — очки не сохраняются.

4. **Удаление старых регистраций**
	- Все старые регистрации, которые были в localStorage, больше не используются. Теперь все новые профили только в файле `src/users.json`.


### Как запускать (теперь всё одной командой)

1. Просто запустите проект командой:
	```sh
	npm start
	```
	Это автоматически запустит и серверную часть (user-api.js), и клиентскую (React-приложение).

2. Серверная часть будет работать на http://localhost:3001, а клиентская — на http://localhost:3000.

3. Все запросы к API (регистрация, вход, обновление очков) идут через прокси на порт 3001.

**Важно:**
- Не нужно запускать сервер вручную — всё делается автоматически.
- Если потребуется изменить путь к серверу, см. скрипт "start" в package.json.

### Для помощника/разработчика

- На текущем этапе все профили пользователей и их очки хранятся только в файле `src/users.json`.
- После регистрации пользователь сразу появляется в этом файле, даже если не сыграл ни одной игры.
- Очки добавляются только если пользователь доиграл раунд до конца.
- Интерфейс регистрации/входа пока минималистичный, планируется доработка UX.
- Старый механизм через localStorage полностью отключён.

Если потребуется изменить логику хранения, добавить экспорт/импорт пользователей или доработать интерфейс — см. этот раздел и код user-api.js.

# Dament

Игра по типу Wordament: разгадывание слов на поле 4x4, синхронные раунды для всех игроков.

## Описание
- Каждая игра длится 2 минуты, затем 40 секунд на подсчёт результатов и вывод лидерборда.
- Игроки могут присоединиться в любой момент.
- Есть темы (например, "Фрукты"), для которых разрешён только определённый список слов.
- После окончания раунда показываются все возможные слова на поле и лидерборд.

## Структура проекта
- `anagramGenerator.ts` — основная игровая логика, генерация поля, тем, слов, учёт результатов и лидерборда.
- `README.md` — описание для разработчиков.
- (Планируется) UI на React или другом фреймворке.

## Описание файлов проекта (русские комментарии)

### Словари
- `src/dictionary.json` — основной словарь (разрешённые слова)
- `src/dictionary.ts` — логика работы со словарём
- `src/letter-bonuses.json` — бонусы за буквы
- `src/ui-strings-categorized.json` — текстовые строки интерфейса
- `src/dictionary-stats.txt` — статистика по словарю

### Игровая логика
- `src/anagramGenerator.ts` — генерация поля, поиск слов
- `src/update-dictionary-stats.js` — обновление статистики словаря
- `src/groupWordsByLetter.js` — группировка слов по буквам

### Интерфейс
- `src/App.tsx` — главный компонент приложения
- `src/GameBoard.tsx` — игровое поле
- `src/Results.tsx` — результаты раунда
- `src/WordInput.tsx` — ввод слова
- `src/Timer.tsx` — таймер
- `src/GameBoard.css` — стили игрового поля

### Прочее

### Анализаторы и статистика
- `src/intersectionAnalyzer.ts` — анализатор пересечений букв на игровом поле. Считает, сколько раз каждая клетка используется в разных словах, помогает оценить "плотность" поля.
- `src/dictionaryAnalyzer.ts` — анализатор связей и статистики букв в словаре. Позволяет анализировать словарь, выявлять связи между словами, сохранять результат в отдельный JSON.
- `src/dictionary-analysis.json` — файл для хранения результатов анализа словаря (автоматически создаётся и обновляется).


## Как найти и изменить словарь

Основной словарь находится в файле `src/dictionary.json`. Если нужно изменить список разрешённых слов — редактируйте этот файл.

Логика работы со словарём реализована в `src/dictionary.ts`.

Если потребуется добавить описание других файлов или изменить структуру — пишите, помогу дополнить!

## Основные функции
- Генерация поля 4x4 (`generateBoard`)
- Проверка слов на поле (`findAllWordsOnBoard`)
- Учёт результатов игроков (`PlayerResult`, `addPlayerResult`, `getLeaderboard`)
- Управление игровым циклом (`startNewRound`, `finishRound`, `nextRound`)

## Этапы разработки
- [x] Базовая игровая логика
- [ ] UI/Frontend
- [ ] Сетевой режим/сервер
- [ ] Хранение истории игр
- [ ] Документация и тесты

## Запуск
(Пока только логика, запуск через Node.js или интеграция с UI)

---

# Для искусственного интеллекта

- Вся логика игры реализована в `anagramGenerator.ts`.
- Структуры данных максимально просты и расширяемы.
- Игровой цикл синхронный, как в Wordament.
- Для интеграции с UI используйте функции управления раундами и генерации поля.
- Для анализа состояния используйте структуры `GameSession`, `PlayerResult`, `Theme`.
- Для расширения: добавить сетевой режим, хранение истории, настройки тем и слов.

## Команды для компиляции и запуска

Для компиляции (сборки) проекта:

```sh
npm run build
```

Для запуска проекта в режиме разработки:

```sh
npm start
```


## Синхронизация изменений через git

Чтобы ваши изменения были доступны на всех устройствах, используйте git и удалённый репозиторий (например, GitHub):

### Отправить изменения с текущего устройства:

```sh
git add .
git commit -m "Краткое описание изменений"
git push
```

### Получить последние изменения на другом устройстве:

```sh
git pull
```

**Примечание:**
- `git add .` — добавить все изменённые файлы
- `git commit -m "..."` — создать коммит с комментарием
- `git push` — отправить изменения в облако
- `git pull` — получить и применить изменения из облака

Так вы всегда будете работать с самой свежей версией проекта на любом устройстве.
