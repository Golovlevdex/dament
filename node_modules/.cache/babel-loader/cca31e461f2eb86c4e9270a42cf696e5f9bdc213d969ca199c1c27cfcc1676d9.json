{"ast":null,"code":"// Типы для бонусов и клетки\n// Генератор тем и анаграмм для игры\n// Общий словарь для генерации анаграмм вне темы\nexport const mainDictionary=[\"дом\",\"река\",\"машина\",\"стол\",\"окно\",\"книга\",\"ручка\",\"город\",\"улица\",\"школа\"// ...добавьте слова\n];// Получить случайное слово из общего словаря\nexport function getRandomWordFromDictionary(){const idx=Math.floor(Math.random()*mainDictionary.length);return mainDictionary[idx];}// Проверить, разрешено ли слово в текущей теме\nexport function isWordAllowedInTheme(word,theme){return theme.words.includes(word);}// Добавить слово в тему\nexport function addWordToTheme(word,theme){if(!theme.words.includes(word)){theme.words.push(word);}}// Удалить слово из темы\nexport function removeWordFromTheme(word,theme){theme.words=theme.words.filter(w=>w!==word);}// Загрузка бонусов для букв из letter-bonuses.json\nimport bonusesJson from'./letter-bonuses.json';export const letterBonuses=bonusesJson;// Генерация игрового поля 4x4 с бонусами из letter-bonuses.json\nexport function generateBoard(theme){const size=4;let letters=[];if(theme){theme.words.forEach(word=>{letters.push(...word.split(\"\"));});}else{mainDictionary.forEach(word=>{letters.push(...word.split(\"\"));});}letters=letters.sort(()=>Math.random()-0.5);const board=[];let idx=0;for(let i=0;i<size;i++){const row=[];for(let j=0;j<size;j++){const letter=letters[idx]||String.fromCharCode(1072+Math.floor(Math.random()*32));row.push({letter,bonus:'none'// устаревшее поле, не используется\n});idx++;}board.push(row);}return board;}// Проверка, можно ли составить слово на поле (по соседним буквам)\nexport function canFormWordOnBoard(word,board){const size=board.length;const visited=Array.from({length:size},()=>Array(size).fill(false));const upperWord=word.toUpperCase();function dfs(x,y,idx){if(idx===upperWord.length)return true;if(x<0||y<0||x>=size||y>=size)return false;if(visited[x][y])return false;if(board[x][y].letter.toUpperCase()!==upperWord[idx])return false;visited[x][y]=true;for(let dx=-1;dx<=1;dx++){for(let dy=-1;dy<=1;dy++){if(dx!==0||dy!==0){if(dfs(x+dx,y+dy,idx+1)){visited[x][y]=false;return true;}}}}visited[x][y]=false;return false;}for(let i=0;i<size;i++){for(let j=0;j<size;j++){if(dfs(i,j,0))return true;}}return false;}// Найти все разрешённые слова, которые реально можно составить на поле\nexport function findAllWordsOnBoard(board,theme){// Используем новый расширенный словарь вместо старого mainDictionary\nconst{gameDictionary}=require('./dictionary');const words=theme?theme.words:gameDictionary;return words.filter(word=>word.length>=3)// только слова от 3 букв\n.filter(word=>canFormWordOnBoard(word.toUpperCase(),board));}// Найти маршруты (пути по клеткам) для всех найденных слов на поле\n/**\r\n * Возвращает маршруты для всех слов, которые реально можно составить на поле\r\n * @param board игровое поле\r\n * @param theme тема (опционально)\r\n * @returns массив маршрутов (WordRoute[]), каждый маршрут — массив позиций клеток\r\n */export function findWordRoutesOnBoard(board,theme){const{gameDictionary}=require('./dictionary');const words=theme?theme.words:gameDictionary;const result=[];for(const word of words){if(word.length<3)continue;const route=getWordRouteOnBoard(word.toUpperCase(),board);if(route)result.push(route);}return result;}/**\r\n * Возвращает маршрут (массив позиций) для слова, если оно реально может быть составлено на поле\r\n * @param word слово\r\n * @param board игровое поле\r\n * @returns маршрут (WordRoute) или null\r\n */function getWordRouteOnBoard(word,board){// Поиск по всем возможным путям (DFS)\nconst rows=board.length;const cols=board[0].length;const visited=Array.from({length:rows},()=>Array(cols).fill(false));let foundRoute=null;function dfs(r,c,idx,route){if(idx===word.length){foundRoute=[...route];return true;}if(r<0||r>=rows||c<0||c>=cols||visited[r][c]||board[r][c].letter!==word[idx]){return false;}visited[r][c]=true;route.push({row:r,col:c});// Перебираем соседей (8 направлений)\nfor(let dr=-1;dr<=1;dr++){for(let dc=-1;dc<=1;dc++){if(dr===0&&dc===0)continue;if(dfs(r+dr,c+dc,idx+1,route)){visited[r][c]=false;route.pop();return true;}}}visited[r][c]=false;route.pop();return false;}for(let r=0;r<rows;r++){for(let c=0;c<cols;c++){if(board[r][c].letter===word[0]){if(dfs(r,c,0,[])){return foundRoute;}}}}return null;}// Структура для хранения результата игрока\n// Массив результатов игроков (например, за текущий раунд)\nexport const playerResults=[];// Добавить результат игрока\nexport function addPlayerResult(result){playerResults.push(result);}// Получить топ-10 игроков по очкам\nexport function getLeaderboard(){return[...playerResults].sort((a,b)=>b.score-a.score).slice(0,10);}// Состояния игры\n// Основная структура текущей игры\n// Текущая игровая сессия\nexport let currentGame=null;// Длительность раунда и паузы (секунды)\nexport const ROUND_DURATION=30;// 30 секунд\nexport const PAUSE_DURATION=15;// 15 секунд\n// Запуск нового раунда\nexport function startNewRound(theme){const now=Date.now();currentGame={state:'playing',timeLeft:ROUND_DURATION,board:generateBoard(theme),theme,startTime:now,endTime:now+ROUND_DURATION*1000};// Здесь можно запустить таймер (например, через setInterval в UI)\n}// Завершение раунда и переход к результатам\nexport function finishRound(){if(!currentGame)return;currentGame.state='results';currentGame.timeLeft=PAUSE_DURATION;currentGame.endTime=Date.now()+PAUSE_DURATION*1000;// Здесь можно показать результаты и лидерборд\n}// Переход к следующему раунду после паузы\nexport function nextRound(theme){startNewRound(theme);}export const themes=[{name:\"Фрукты\",reward:\"Значок Фрукты\",words:[\"яблоко\",\"банан\",\"груша\",\"апельсин\"]},{name:\"Животные\",reward:\"Значок Животные\",words:[\"тигр\",\"лев\",\"слон\",\"волк\"]}// ...добавьте остальные темы\n];// Получить следующую тему по кругу\nexport function getNextTheme(currentIndex){const nextIndex=(currentIndex+1)%themes.length;return{theme:themes[nextIndex],nextIndex};}// Получить случайное слово из темы\nexport function getRandomWord(theme){const idx=Math.floor(Math.random()*theme.words.length);return theme.words[idx];}// Перемешать буквы в слове (анаграмма)\nexport function shuffleWord(word){return word.split(\"\").sort(()=>Math.random()-0.5).join(\"\");}// Пример использования:\n// let currentThemeIndex = 0;\n// let { theme, nextIndex } = getNextTheme(currentThemeIndex);\n// let word = getRandomWord(theme);\n// let anagram = shuffleWord(word);\n// console.log(`Тема: ${theme.name}, Анаграмма: ${anagram}`);","map":{"version":3,"names":["mainDictionary","getRandomWordFromDictionary","idx","Math","floor","random","length","isWordAllowedInTheme","word","theme","words","includes","addWordToTheme","push","removeWordFromTheme","filter","w","bonusesJson","letterBonuses","generateBoard","size","letters","forEach","split","sort","board","i","row","j","letter","String","fromCharCode","bonus","canFormWordOnBoard","visited","Array","from","fill","upperWord","toUpperCase","dfs","x","y","dx","dy","findAllWordsOnBoard","gameDictionary","require","findWordRoutesOnBoard","result","route","getWordRouteOnBoard","rows","cols","foundRoute","r","c","col","dr","dc","pop","playerResults","addPlayerResult","getLeaderboard","a","b","score","slice","currentGame","ROUND_DURATION","PAUSE_DURATION","startNewRound","now","Date","state","timeLeft","startTime","endTime","finishRound","nextRound","themes","name","reward","getNextTheme","currentIndex","nextIndex","getRandomWord","shuffleWord","join"],"sources":["C:/vsc/dament/src/anagramGenerator.ts"],"sourcesContent":["// Типы для бонусов и клетки\r\nexport type BonusType = 'none' | 'doubleLetter' | 'rareBonus';\r\nexport interface Cell {\r\n  letter: string;\r\n  bonus: BonusType;\r\n}\r\n// Генератор тем и анаграмм для игры\r\n\r\nexport type Theme = {\r\n  name: string;\r\n  reward: string;\r\n  words: string[];\r\n};\r\n// Общий словарь для генерации анаграмм вне темы\r\nexport const mainDictionary: string[] = [\r\n  \"дом\", \"река\", \"машина\", \"стол\", \"окно\", \"книга\", \"ручка\", \"город\", \"улица\", \"школа\"\r\n  // ...добавьте слова\r\n];\r\n\r\n// Получить случайное слово из общего словаря\r\nexport function getRandomWordFromDictionary(): string {\r\n  const idx = Math.floor(Math.random() * mainDictionary.length);\r\n  return mainDictionary[idx];\r\n}\r\n\r\n// Проверить, разрешено ли слово в текущей теме\r\nexport function isWordAllowedInTheme(word: string, theme: Theme): boolean {\r\n  return theme.words.includes(word);\r\n}\r\n\r\n// Добавить слово в тему\r\nexport function addWordToTheme(word: string, theme: Theme): void {\r\n  if (!theme.words.includes(word)) {\r\n    theme.words.push(word);\r\n  }\r\n}\r\n\r\n// Удалить слово из темы\r\nexport function removeWordFromTheme(word: string, theme: Theme): void {\r\n  theme.words = theme.words.filter(w => w !== word);\r\n}\r\n\r\n// Загрузка бонусов для букв из letter-bonuses.json\r\nimport bonusesJson from './letter-bonuses.json';\r\nexport const letterBonuses: Record<string, number> = bonusesJson;\r\n\r\n// Генерация игрового поля 4x4 с бонусами из letter-bonuses.json\r\nexport function generateBoard(theme?: Theme): Cell[][] {\r\n  const size = 4;\r\n  let letters: string[] = [];\r\n  if (theme) {\r\n    theme.words.forEach(word => {\r\n      letters.push(...word.split(\"\"));\r\n    });\r\n  } else {\r\n    mainDictionary.forEach(word => {\r\n      letters.push(...word.split(\"\"));\r\n    });\r\n  }\r\n  letters = letters.sort(() => Math.random() - 0.5);\r\n  const board: Cell[][] = [];\r\n  let idx = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const row: Cell[] = [];\r\n    for (let j = 0; j < size; j++) {\r\n      const letter = letters[idx] || String.fromCharCode(1072 + Math.floor(Math.random() * 32));\r\n      row.push({\r\n        letter,\r\n        bonus: 'none' // устаревшее поле, не используется\r\n      });\r\n      idx++;\r\n    }\r\n    board.push(row);\r\n  }\r\n  return board;\r\n}\r\n\r\n// Проверка, можно ли составить слово на поле (по соседним буквам)\r\nexport function canFormWordOnBoard(word: string, board: Cell[][]): boolean {\r\n  const size = board.length;\r\n  const visited: boolean[][] = Array.from({ length: size }, () => Array(size).fill(false));\r\n  const upperWord = word.toUpperCase();\r\n\r\n  function dfs(x: number, y: number, idx: number): boolean {\r\n    if (idx === upperWord.length) return true;\r\n    if (x < 0 || y < 0 || x >= size || y >= size) return false;\r\n    if (visited[x][y]) return false;\r\n    if (board[x][y].letter.toUpperCase() !== upperWord[idx]) return false;\r\n    visited[x][y] = true;\r\n    for (let dx = -1; dx <= 1; dx++) {\r\n      for (let dy = -1; dy <= 1; dy++) {\r\n        if (dx !== 0 || dy !== 0) {\r\n          if (dfs(x + dx, y + dy, idx + 1)) {\r\n            visited[x][y] = false;\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    visited[x][y] = false;\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    for (let j = 0; j < size; j++) {\r\n      if (dfs(i, j, 0)) return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Найти все разрешённые слова, которые реально можно составить на поле\r\nexport function findAllWordsOnBoard(board: Cell[][], theme?: Theme): string[] {\r\n  // Используем новый расширенный словарь вместо старого mainDictionary\r\n  const { gameDictionary } = require('./dictionary');\r\n  const words = theme ? theme.words : gameDictionary;\r\n  return words\r\n    .filter((word: string) => word.length >= 3) // только слова от 3 букв\r\n    .filter((word: string) => canFormWordOnBoard(word.toUpperCase(), board));\r\n}\r\n\r\n// Найти маршруты (пути по клеткам) для всех найденных слов на поле\r\nimport { CellPosition, WordRoute } from \"./intersectionAnalyzer\";\r\n\r\n/**\r\n * Возвращает маршруты для всех слов, которые реально можно составить на поле\r\n * @param board игровое поле\r\n * @param theme тема (опционально)\r\n * @returns массив маршрутов (WordRoute[]), каждый маршрут — массив позиций клеток\r\n */\r\nexport function findWordRoutesOnBoard(board: Cell[][], theme?: Theme): WordRoute[] {\r\n  const { gameDictionary } = require('./dictionary');\r\n  const words = theme ? theme.words : gameDictionary;\r\n  const result: WordRoute[] = [];\r\n  for (const word of words) {\r\n    if (word.length < 3) continue;\r\n    const route = getWordRouteOnBoard(word.toUpperCase(), board);\r\n    if (route) result.push(route);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Возвращает маршрут (массив позиций) для слова, если оно реально может быть составлено на поле\r\n * @param word слово\r\n * @param board игровое поле\r\n * @returns маршрут (WordRoute) или null\r\n */\r\nfunction getWordRouteOnBoard(word: string, board: Cell[][]): WordRoute | null {\r\n  // Поиск по всем возможным путям (DFS)\r\n  const rows = board.length;\r\n  const cols = board[0].length;\r\n  const visited: boolean[][] = Array.from({ length: rows }, () => Array(cols).fill(false));\r\n  let foundRoute: WordRoute | null = null;\r\n\r\n  function dfs(r: number, c: number, idx: number, route: WordRoute): boolean {\r\n    if (idx === word.length) {\r\n      foundRoute = [...route];\r\n      return true;\r\n    }\r\n    if (\r\n      r < 0 || r >= rows ||\r\n      c < 0 || c >= cols ||\r\n      visited[r][c] ||\r\n      board[r][c].letter !== word[idx]\r\n    ) {\r\n      return false;\r\n    }\r\n    visited[r][c] = true;\r\n    route.push({ row: r, col: c });\r\n    // Перебираем соседей (8 направлений)\r\n    for (let dr = -1; dr <= 1; dr++) {\r\n      for (let dc = -1; dc <= 1; dc++) {\r\n        if (dr === 0 && dc === 0) continue;\r\n        if (dfs(r + dr, c + dc, idx + 1, route)) {\r\n          visited[r][c] = false;\r\n          route.pop();\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    visited[r][c] = false;\r\n    route.pop();\r\n    return false;\r\n  }\r\n\r\n  for (let r = 0; r < rows; r++) {\r\n    for (let c = 0; c < cols; c++) {\r\n      if (board[r][c].letter === word[0]) {\r\n        if (dfs(r, c, 0, [])) {\r\n          return foundRoute;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n// Структура для хранения результата игрока\r\nexport type PlayerResult = {\r\n  name: string;\r\n  score: number;\r\n  foundWords: string[];\r\n};\r\n\r\n// Массив результатов игроков (например, за текущий раунд)\r\nexport const playerResults: PlayerResult[] = [];\r\n\r\n// Добавить результат игрока\r\nexport function addPlayerResult(result: PlayerResult): void {\r\n  playerResults.push(result);\r\n}\r\n\r\n// Получить топ-10 игроков по очкам\r\nexport function getLeaderboard(): PlayerResult[] {\r\n  return [...playerResults].sort((a, b) => b.score - a.score).slice(0, 10);\r\n}\r\n\r\n// Состояния игры\r\nexport type GameState = 'playing' | 'results';\r\n\r\n// Основная структура текущей игры\r\nexport type GameSession = {\r\n  state: GameState;\r\n  timeLeft: number; // секунды\r\n  board: Cell[][];\r\n  theme?: Theme;\r\n  startTime: number;\r\n  endTime: number;\r\n};\r\n\r\n// Текущая игровая сессия\r\nexport let currentGame: GameSession | null = null;\r\n\r\n// Длительность раунда и паузы (секунды)\r\nexport const ROUND_DURATION = 30; // 30 секунд\r\nexport const PAUSE_DURATION = 15;  // 15 секунд\r\n\r\n// Запуск нового раунда\r\nexport function startNewRound(theme?: Theme) {\r\n  const now = Date.now();\r\n  currentGame = {\r\n    state: 'playing',\r\n    timeLeft: ROUND_DURATION,\r\n    board: generateBoard(theme),\r\n    theme,\r\n    startTime: now,\r\n    endTime: now + ROUND_DURATION * 1000\r\n  };\r\n  // Здесь можно запустить таймер (например, через setInterval в UI)\r\n}\r\n\r\n// Завершение раунда и переход к результатам\r\nexport function finishRound() {\r\n  if (!currentGame) return;\r\n  currentGame.state = 'results';\r\n  currentGame.timeLeft = PAUSE_DURATION;\r\n  currentGame.endTime = Date.now() + PAUSE_DURATION * 1000;\r\n  // Здесь можно показать результаты и лидерборд\r\n}\r\n\r\n// Переход к следующему раунду после паузы\r\nexport function nextRound(theme?: Theme) {\r\n  startNewRound(theme);\r\n}\r\n\r\nexport const themes: Theme[] = [\r\n  {\r\n    name: \"Фрукты\",\r\n    reward: \"Значок Фрукты\",\r\n    words: [\"яблоко\", \"банан\", \"груша\", \"апельсин\"]\r\n  },\r\n  {\r\n    name: \"Животные\",\r\n    reward: \"Значок Животные\",\r\n    words: [\"тигр\", \"лев\", \"слон\", \"волк\"]\r\n  },\r\n  // ...добавьте остальные темы\r\n];\r\n\r\n// Получить следующую тему по кругу\r\nexport function getNextTheme(currentIndex: number): { theme: Theme; nextIndex: number } {\r\n  const nextIndex = (currentIndex + 1) % themes.length;\r\n  return { theme: themes[nextIndex], nextIndex };\r\n}\r\n\r\n// Получить случайное слово из темы\r\nexport function getRandomWord(theme: Theme): string {\r\n  const idx = Math.floor(Math.random() * theme.words.length);\r\n  return theme.words[idx];\r\n}\r\n\r\n// Перемешать буквы в слове (анаграмма)\r\nexport function shuffleWord(word: string): string {\r\n  return word.split(\"\").sort(() => Math.random() - 0.5).join(\"\");\r\n}\r\n\r\n// Пример использования:\r\n// let currentThemeIndex = 0;\r\n// let { theme, nextIndex } = getNextTheme(currentThemeIndex);\r\n// let word = getRandomWord(theme);\r\n// let anagram = shuffleWord(word);\r\n// console.log(`Тема: ${theme.name}, Анаграмма: ${anagram}`);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}