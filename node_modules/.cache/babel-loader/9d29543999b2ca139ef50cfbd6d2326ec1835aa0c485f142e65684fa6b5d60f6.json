{"ast":null,"code":"// Типы для бонусов и клетки\n\n// Генератор тем и анаграмм для игры\n\n// Общий словарь для генерации анаграмм вне темы\nexport const mainDictionary = [\"дом\", \"река\", \"машина\", \"стол\", \"окно\", \"книга\", \"ручка\", \"город\", \"улица\", \"школа\"\n// ...добавьте слова\n];\n\n// Получить случайное слово из общего словаря\nexport function getRandomWordFromDictionary() {\n  const idx = Math.floor(Math.random() * mainDictionary.length);\n  return mainDictionary[idx];\n}\n\n// Проверить, разрешено ли слово в текущей теме\nexport function isWordAllowedInTheme(word, theme) {\n  return theme.words.includes(word);\n}\n\n// Добавить слово в тему\nexport function addWordToTheme(word, theme) {\n  if (!theme.words.includes(word)) {\n    theme.words.push(word);\n  }\n}\n\n// Удалить слово из темы\nexport function removeWordFromTheme(word, theme) {\n  theme.words = theme.words.filter(w => w !== word);\n}\n\n// Загрузка бонусов для букв из letter-bonuses.json\nimport bonusesJson from './letter-bonuses.json';\nexport const letterBonuses = bonusesJson;\n\n// Генерация игрового поля 4x4 с бонусами из letter-bonuses.json\nexport function generateBoard(theme) {\n  const size = 4;\n  let letters = [];\n  if (theme) {\n    theme.words.forEach(word => {\n      letters.push(...word.split(\"\"));\n    });\n  } else {\n    mainDictionary.forEach(word => {\n      letters.push(...word.split(\"\"));\n    });\n  }\n  letters = letters.sort(() => Math.random() - 0.5);\n  const board = [];\n  let idx = 0;\n  for (let i = 0; i < size; i++) {\n    const row = [];\n    for (let j = 0; j < size; j++) {\n      const letter = letters[idx] || String.fromCharCode(1072 + Math.floor(Math.random() * 32));\n      row.push({\n        letter,\n        bonus: 'none' // устаревшее поле, не используется\n      });\n      idx++;\n    }\n    board.push(row);\n  }\n  return board;\n}\n\n// Проверка, можно ли составить слово на поле (по соседним буквам)\nexport function canFormWordOnBoard(word, board) {\n  const size = board.length;\n  const visited = Array.from({\n    length: size\n  }, () => Array(size).fill(false));\n  const upperWord = word.toUpperCase();\n  function dfs(x, y, idx) {\n    if (idx === upperWord.length) return true;\n    if (x < 0 || y < 0 || x >= size || y >= size) return false;\n    if (visited[x][y]) return false;\n    if (board[x][y].letter.toUpperCase() !== upperWord[idx]) return false;\n    visited[x][y] = true;\n    for (let dx = -1; dx <= 1; dx++) {\n      for (let dy = -1; dy <= 1; dy++) {\n        if (dx !== 0 || dy !== 0) {\n          if (dfs(x + dx, y + dy, idx + 1)) {\n            visited[x][y] = false;\n            return true;\n          }\n        }\n      }\n    }\n    visited[x][y] = false;\n    return false;\n  }\n  for (let i = 0; i < size; i++) {\n    for (let j = 0; j < size; j++) {\n      if (dfs(i, j, 0)) return true;\n    }\n  }\n  return false;\n}\n\n// Найти все разрешённые слова, которые реально можно составить на поле\nexport function findAllWordsOnBoard(board, theme) {\n  // Используем новый расширенный словарь вместо старого mainDictionary\n  const {\n    gameDictionary\n  } = require('./dictionary');\n  const words = theme ? theme.words : gameDictionary;\n  return words.filter(word => word.length >= 3) // только слова от 3 букв\n  .filter(word => canFormWordOnBoard(word.toUpperCase(), board));\n}\n\n// Структура для хранения результата игрока\n\n// Массив результатов игроков (например, за текущий раунд)\nexport const playerResults = [];\n\n// Добавить результат игрока\nexport function addPlayerResult(result) {\n  playerResults.push(result);\n}\n\n// Получить топ-10 игроков по очкам\nexport function getLeaderboard() {\n  return [...playerResults].sort((a, b) => b.score - a.score).slice(0, 10);\n}\n\n// Состояния игры\n\n// Основная структура текущей игры\n\n// Текущая игровая сессия\nexport let currentGame = null;\n\n// Длительность раунда и паузы (секунды)\nexport const ROUND_DURATION = 15; // 15 секунд\nexport const PAUSE_DURATION = 15; // 15 секунд\n\n// Запуск нового раунда\nexport function startNewRound(theme) {\n  const now = Date.now();\n  currentGame = {\n    state: 'playing',\n    timeLeft: ROUND_DURATION,\n    board: generateBoard(theme),\n    theme,\n    startTime: now,\n    endTime: now + ROUND_DURATION * 1000\n  };\n  // Здесь можно запустить таймер (например, через setInterval в UI)\n}\n\n// Завершение раунда и переход к результатам\nexport function finishRound() {\n  if (!currentGame) return;\n  currentGame.state = 'results';\n  currentGame.timeLeft = PAUSE_DURATION;\n  currentGame.endTime = Date.now() + PAUSE_DURATION * 1000;\n  // Здесь можно показать результаты и лидерборд\n}\n\n// Переход к следующему раунду после паузы\nexport function nextRound(theme) {\n  startNewRound(theme);\n}\nexport const themes = [{\n  name: \"Фрукты\",\n  reward: \"Значок Фрукты\",\n  words: [\"яблоко\", \"банан\", \"груша\", \"апельсин\"]\n}, {\n  name: \"Животные\",\n  reward: \"Значок Животные\",\n  words: [\"тигр\", \"лев\", \"слон\", \"волк\"]\n}\n// ...добавьте остальные темы\n];\n\n// Получить следующую тему по кругу\nexport function getNextTheme(currentIndex) {\n  const nextIndex = (currentIndex + 1) % themes.length;\n  return {\n    theme: themes[nextIndex],\n    nextIndex\n  };\n}\n\n// Получить случайное слово из темы\nexport function getRandomWord(theme) {\n  const idx = Math.floor(Math.random() * theme.words.length);\n  return theme.words[idx];\n}\n\n// Перемешать буквы в слове (анаграмма)\nexport function shuffleWord(word) {\n  return word.split(\"\").sort(() => Math.random() - 0.5).join(\"\");\n}\n\n// Пример использования:\n// let currentThemeIndex = 0;\n// let { theme, nextIndex } = getNextTheme(currentThemeIndex);\n// let word = getRandomWord(theme);\n// let anagram = shuffleWord(word);\n// console.log(`Тема: ${theme.name}, Анаграмма: ${anagram}`);","map":{"version":3,"names":["mainDictionary","getRandomWordFromDictionary","idx","Math","floor","random","length","isWordAllowedInTheme","word","theme","words","includes","addWordToTheme","push","removeWordFromTheme","filter","w","bonusesJson","letterBonuses","generateBoard","size","letters","forEach","split","sort","board","i","row","j","letter","String","fromCharCode","bonus","canFormWordOnBoard","visited","Array","from","fill","upperWord","toUpperCase","dfs","x","y","dx","dy","findAllWordsOnBoard","gameDictionary","require","playerResults","addPlayerResult","result","getLeaderboard","a","b","score","slice","currentGame","ROUND_DURATION","PAUSE_DURATION","startNewRound","now","Date","state","timeLeft","startTime","endTime","finishRound","nextRound","themes","name","reward","getNextTheme","currentIndex","nextIndex","getRandomWord","shuffleWord","join"],"sources":["C:/vsc/dament/src/anagramGenerator.ts"],"sourcesContent":["// Типы для бонусов и клетки\r\nexport type BonusType = 'none' | 'doubleLetter' | 'rareBonus';\r\nexport interface Cell {\r\n  letter: string;\r\n  bonus: BonusType;\r\n}\r\n// Генератор тем и анаграмм для игры\r\n\r\nexport type Theme = {\r\n  name: string;\r\n  reward: string;\r\n  words: string[];\r\n};\r\n// Общий словарь для генерации анаграмм вне темы\r\nexport const mainDictionary: string[] = [\r\n  \"дом\", \"река\", \"машина\", \"стол\", \"окно\", \"книга\", \"ручка\", \"город\", \"улица\", \"школа\"\r\n  // ...добавьте слова\r\n];\r\n\r\n// Получить случайное слово из общего словаря\r\nexport function getRandomWordFromDictionary(): string {\r\n  const idx = Math.floor(Math.random() * mainDictionary.length);\r\n  return mainDictionary[idx];\r\n}\r\n\r\n// Проверить, разрешено ли слово в текущей теме\r\nexport function isWordAllowedInTheme(word: string, theme: Theme): boolean {\r\n  return theme.words.includes(word);\r\n}\r\n\r\n// Добавить слово в тему\r\nexport function addWordToTheme(word: string, theme: Theme): void {\r\n  if (!theme.words.includes(word)) {\r\n    theme.words.push(word);\r\n  }\r\n}\r\n\r\n// Удалить слово из темы\r\nexport function removeWordFromTheme(word: string, theme: Theme): void {\r\n  theme.words = theme.words.filter(w => w !== word);\r\n}\r\n\r\n// Загрузка бонусов для букв из letter-bonuses.json\r\nimport bonusesJson from './letter-bonuses.json';\r\nexport const letterBonuses: Record<string, number> = bonusesJson;\r\n\r\n// Генерация игрового поля 4x4 с бонусами из letter-bonuses.json\r\nexport function generateBoard(theme?: Theme): Cell[][] {\r\n  const size = 4;\r\n  let letters: string[] = [];\r\n  if (theme) {\r\n    theme.words.forEach(word => {\r\n      letters.push(...word.split(\"\"));\r\n    });\r\n  } else {\r\n    mainDictionary.forEach(word => {\r\n      letters.push(...word.split(\"\"));\r\n    });\r\n  }\r\n  letters = letters.sort(() => Math.random() - 0.5);\r\n  const board: Cell[][] = [];\r\n  let idx = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const row: Cell[] = [];\r\n    for (let j = 0; j < size; j++) {\r\n      const letter = letters[idx] || String.fromCharCode(1072 + Math.floor(Math.random() * 32));\r\n      row.push({\r\n        letter,\r\n        bonus: 'none' // устаревшее поле, не используется\r\n      });\r\n      idx++;\r\n    }\r\n    board.push(row);\r\n  }\r\n  return board;\r\n}\r\n\r\n// Проверка, можно ли составить слово на поле (по соседним буквам)\r\nexport function canFormWordOnBoard(word: string, board: Cell[][]): boolean {\r\n  const size = board.length;\r\n  const visited: boolean[][] = Array.from({ length: size }, () => Array(size).fill(false));\r\n  const upperWord = word.toUpperCase();\r\n\r\n  function dfs(x: number, y: number, idx: number): boolean {\r\n    if (idx === upperWord.length) return true;\r\n    if (x < 0 || y < 0 || x >= size || y >= size) return false;\r\n    if (visited[x][y]) return false;\r\n    if (board[x][y].letter.toUpperCase() !== upperWord[idx]) return false;\r\n    visited[x][y] = true;\r\n    for (let dx = -1; dx <= 1; dx++) {\r\n      for (let dy = -1; dy <= 1; dy++) {\r\n        if (dx !== 0 || dy !== 0) {\r\n          if (dfs(x + dx, y + dy, idx + 1)) {\r\n            visited[x][y] = false;\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    visited[x][y] = false;\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    for (let j = 0; j < size; j++) {\r\n      if (dfs(i, j, 0)) return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Найти все разрешённые слова, которые реально можно составить на поле\r\nexport function findAllWordsOnBoard(board: Cell[][], theme?: Theme): string[] {\r\n  // Используем новый расширенный словарь вместо старого mainDictionary\r\n  const { gameDictionary } = require('./dictionary');\r\n  const words = theme ? theme.words : gameDictionary;\r\n  return words\r\n    .filter((word: string) => word.length >= 3) // только слова от 3 букв\r\n    .filter((word: string) => canFormWordOnBoard(word.toUpperCase(), board));\r\n}\r\n\r\n// Структура для хранения результата игрока\r\nexport type PlayerResult = {\r\n  name: string;\r\n  score: number;\r\n  foundWords: string[];\r\n};\r\n\r\n// Массив результатов игроков (например, за текущий раунд)\r\nexport const playerResults: PlayerResult[] = [];\r\n\r\n// Добавить результат игрока\r\nexport function addPlayerResult(result: PlayerResult): void {\r\n  playerResults.push(result);\r\n}\r\n\r\n// Получить топ-10 игроков по очкам\r\nexport function getLeaderboard(): PlayerResult[] {\r\n  return [...playerResults].sort((a, b) => b.score - a.score).slice(0, 10);\r\n}\r\n\r\n// Состояния игры\r\nexport type GameState = 'playing' | 'results';\r\n\r\n// Основная структура текущей игры\r\nexport type GameSession = {\r\n  state: GameState;\r\n  timeLeft: number; // секунды\r\n  board: Cell[][];\r\n  theme?: Theme;\r\n  startTime: number;\r\n  endTime: number;\r\n};\r\n\r\n// Текущая игровая сессия\r\nexport let currentGame: GameSession | null = null;\r\n\r\n// Длительность раунда и паузы (секунды)\r\nexport const ROUND_DURATION = 15; // 15 секунд\r\nexport const PAUSE_DURATION = 15;  // 15 секунд\r\n\r\n// Запуск нового раунда\r\nexport function startNewRound(theme?: Theme) {\r\n  const now = Date.now();\r\n  currentGame = {\r\n    state: 'playing',\r\n    timeLeft: ROUND_DURATION,\r\n    board: generateBoard(theme),\r\n    theme,\r\n    startTime: now,\r\n    endTime: now + ROUND_DURATION * 1000\r\n  };\r\n  // Здесь можно запустить таймер (например, через setInterval в UI)\r\n}\r\n\r\n// Завершение раунда и переход к результатам\r\nexport function finishRound() {\r\n  if (!currentGame) return;\r\n  currentGame.state = 'results';\r\n  currentGame.timeLeft = PAUSE_DURATION;\r\n  currentGame.endTime = Date.now() + PAUSE_DURATION * 1000;\r\n  // Здесь можно показать результаты и лидерборд\r\n}\r\n\r\n// Переход к следующему раунду после паузы\r\nexport function nextRound(theme?: Theme) {\r\n  startNewRound(theme);\r\n}\r\n\r\nexport const themes: Theme[] = [\r\n  {\r\n    name: \"Фрукты\",\r\n    reward: \"Значок Фрукты\",\r\n    words: [\"яблоко\", \"банан\", \"груша\", \"апельсин\"]\r\n  },\r\n  {\r\n    name: \"Животные\",\r\n    reward: \"Значок Животные\",\r\n    words: [\"тигр\", \"лев\", \"слон\", \"волк\"]\r\n  },\r\n  // ...добавьте остальные темы\r\n];\r\n\r\n// Получить следующую тему по кругу\r\nexport function getNextTheme(currentIndex: number): { theme: Theme; nextIndex: number } {\r\n  const nextIndex = (currentIndex + 1) % themes.length;\r\n  return { theme: themes[nextIndex], nextIndex };\r\n}\r\n\r\n// Получить случайное слово из темы\r\nexport function getRandomWord(theme: Theme): string {\r\n  const idx = Math.floor(Math.random() * theme.words.length);\r\n  return theme.words[idx];\r\n}\r\n\r\n// Перемешать буквы в слове (анаграмма)\r\nexport function shuffleWord(word: string): string {\r\n  return word.split(\"\").sort(() => Math.random() - 0.5).join(\"\");\r\n}\r\n\r\n// Пример использования:\r\n// let currentThemeIndex = 0;\r\n// let { theme, nextIndex } = getNextTheme(currentThemeIndex);\r\n// let word = getRandomWord(theme);\r\n// let anagram = shuffleWord(word);\r\n// console.log(`Тема: ${theme.name}, Анаграмма: ${anagram}`);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}